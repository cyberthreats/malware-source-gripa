mk:		pusha
		cld
		mov	edi, [esp + 36]
		mov	esi, [esp + 40]

		mov	eax, esi
		xor	ebx, ebx
		inc	eax
		shr	eax, 1
		jz	.s1
.s0:		inc	ebx
		sub	eax, ebx
		jg	.s0
.s1:
		mov	edx, ebx
.next:		mov	eax, ebx
		push	edx
		mul	edx
		pop	edx
		cmp	eax, esi
		jae	.done
		inc	edx
		jmp	.next
.done:		sub	eax, esi
		mov	ebp, eax
	
		mov	al, '>'
		stosb
	
		mov	al, '+'
		mov	ecx, ebx
		rep	stosb
	
		mov	ax, '[' | ('<' << 8)
		stosw
		
		mov	al, '+'
		mov	ecx, edx
		rep	stosb
	
		mov	eax, '>' | ('-' << 8) | (']' << 16) | ('<' << 24)
		stosd
	
		or	ebp, ebp
		js	.do_sub
		mov	al, '-'
		jmp	.do
.do_sub:	mov	al, '+'
		neg	ebp
.do:		mov	ecx, ebp
		rep	stosb

		mov	al, '>'
		stosb
	
		mov	[esp + 28], edi
		popa
		retn	8

mk_key:		pusha
		mov	edi, [esp + 36]
		mov	ecx, 16
	
		lea	esi, [edi + 1004]
		; init seed
		call	mk_seed
		lea	ebp, [esi + 16]
		mov	[ebp], eax

.gkey:		; get 1 byte of key
		push	256
		push	ebp
		call	random

		; save key
		mov	byte [esi], al
		inc	esi
	
		; generate bf code
		push	eax
		push	edi
		call	mk
		mov	edi, eax
		loop	.gkey
	
		mov	[esp + 28], edi
		popa
		ret

mk_seed:	push	edx
		push	ebx
		movb	eax, 13
		int	0x80		; time
		xchg	eax, ebx
		movb	eax, 20
		int	0x80		; getpid
		xor	ebx, eax
		rdtsc
		xor	eax, ebx
		xor	eax, edx
		pop	ebx
		pop	edx
		ret

random:		pusha
		mov	ecx, [esp + 36]
		mov	eax, [ecx]
		imul	eax, 214013
		add	eax, 2531011
		mov	[ecx], eax
		shr	eax, 16
		imul	eax, [esp + 40]
		shr     eax, 16
		mov	[esp + 28], eax
		popa
		retn	8
