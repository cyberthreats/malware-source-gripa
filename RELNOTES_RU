- su.virus (2:465/215) --------------------------------------------- su.virus -
 From : andrew baranovich                   2:465/215       sat 09 jul 05 18:03
 To   : All                                                 sat 09 jul 05 18:03
 Subj : Obfuscated! :-)
-------------------------------------------------------------------------------

        здравствуйте, уважаемые! Ж-)

        решил на днях поразмяться малость,  а то так и забыть
        не долго, что такое языки программирования. результат
        "разминки" перед вами.

        это - стандартный линуксовый arch (
             # rpm -qf `which arch`
             util-linux-2.11f-12.asp
        ), зараженный шифрованым и  легонько  обфусцированным
        вирусом. к сожалению,  слово  'obfuscated'  не  имеет
        равноценного аналога в русском языке.  развлекайтесь!
        я, к примеру, получил массу удовольствия.

        естественно, что ни исходники,  ни описание я постить
        не собираюсь, пока не выйдет лечилка. а то,  в чем бы
        был прикол? Ж-))) собственно, за основу я взял другой
        свой вирус, отключив кернельную часть для простоты.
        стоп, стоп, стоп. что-то я разболтался. Ж-)))

- su.virus (2:465/215) --------------------------------------------- su.virus -
 From : andrew baranovich                   2:465/215       thu 14 jul 05 09:36
 To   : Yuriy Saloid                                        thu 14 jul 05 09:37
 Subj : Virus.Linux.Grip.a, was: Obfuscated! :-)
-------------------------------------------------------------------------------
Yuriy Saloid wrote to Alexey Podtoptalow:

 YS>  ... неплохо б автор поста расписал еще механизм работы заразы,
 YS> размножения, способы проникновения в систему - а то ОБФУСЦИРУЕТ что-то
 YS> больно ;)

        все на самом деле довольно просто. есть такой волшебный язык
        программирования BrainFuck (относится к семейству "эзотерических"),
        который был создан Урбаном Мюллером (Urban Mueller) где-то в 1993,
        с целью получить минимальный язык обладающий тьюринг-полнотой.
        должен вам сказать, что своей задачи он добился. в языке восемь
        операторов:

|       +   +1 к значению ячейки под указателем
|       -   -1 к значению ячейки под указателем
|       <   указатель влево
|       >   указатель вправо
|       .   вывести значение текущей ячейки
|       ,   ввести значение для текущей ячейки
|       [   если 0, перейти к парной ]
|       ]   если НЕ 0, перейти к парной [

        таким образом, простейший конвертер из BrainFuck в Си можно
        за 2 минуты (ровно столько у меня ушло времени) написать на
        sed:

|       $cat bfcc.sed
|       1a      \
|       main(){char c[30000],*p=c;memset(c,0,30000);
|       # strip comments
|       s/[a-zA-Z0-9\|\\\(\)\$\^\-\*#=]//g
|       s/+/++*p;/g
|       s/-/--*p;/g
|       s/</--p;/g
|       s/>/++p;/g
|       s/\./putchar(*p);/g
|       s/\,/*p=getchar();/g
|       s/\]/}/g
|       s/\[/while(*p)\{/g
|       $a      \
|       }
|
|       $ cat hello.bf
|       Hello World program
|       >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++.
|       .+++.[-]>++++++++[<++++>-]<.#>+++++++++++[<+++++>-]<.
|       >++++++++[<+++>-]<.+++.------.--------.[-]>++++++++[<
|       ++++>-]<+.[-]++++++++++.
|
|       $ sed -f bfcc.sed hello.bf|gcc -xc -o hello -
|       $ ./hello
|       Hello World!

        да, вот еще несколько особенностей:

        [ и ] соответствуют обычным правилам для скобочных выражений.
        лента состоит из 30000 байт и первоначально содержит нули. EOF
        не меняет значение ячейки. выход за границы ленты и неправильно
        раставленные скобки генерируют ошибку. EOL - 0x0A, все символы,
        в программе, кроме перечисленных игнорируются. вот интерпретатор
        BrainFuck написаный на BrainFuck:

|       >>>+[[-]>>[-]++>+>+++++++[<++++>>++<-]++>>+>+>+++++[>++>++++++
|       <<-]+>>>,<++[[>[->>]<[>>]<<-]<[<]<+>>[>]>[<+>-[[<+>-]>]<[[[-]<
|       ]++<-[<+++++++++>[<->-]>>]>>]]<<]<]<[[<]>[[>]>>[>>]+[<<]<[<]<+
|       >>-]>[>]+[->>]<<<<[[<<]<[<]+<<[+>+<<-[>-->+<<-[>+<[>>+<<-]]]>[
|       <+>-]<]++>>-->[>]>>[>>]]<<[>>+<[[<]<]>[[<<]<[<]+[-<+>>-[<<+>++
|       >-[<->[<<+>>-]]]<[>+<-]>]>[>]>]>[>>]>>]<<[>>+>>+>>]<<[->>>>>>>
|       >]<<[>.>>>>>>>]<<[>->>>>>]<<[>,>>>]<<[>+>]<<[+<<]<]
        [input a brainfuck program and its input, separated by an
        exclamation point. Daniel B Cristofani (cristofdathevanetdotcom)
        http://www.hevanet.com/cristofd/brainfuck/]

        или на C (автора не знаю):

        char m[9999],*n[99],*r=m,*p=m+5000,**s=n,d,c;main(){for(read(0,r,p)
        ;c=*r++;c-93?c-91?d?0:c-43&~2?c-44?c-46?p+=c&~2^60?0:c%4-1:write(1,
        p,1):read(2,p,1):(*p-=c-44):d++||(*++s=r):d&&--d?0:*p?r=*s:--s);}

        и наконец мой интерпретатор:

; BrainFuck interpreter herm1t'2005 (http://vx.netlux.org/herm1t/)
; все фичи выключены
; void bf(uint8_t *code, uint8_t *core, int(*gc)(void),int(*pc)(int))
bfi:    db  0x60, 0x89, 0xe5, 0x8b, 0x75, 0x24, 0x8b, 0x7d
        db  0x28, 0xfc, 0xe8, 0x02, 0x00, 0x00, 0x00, 0xeb
        db  0xf9, 0x31, 0xc0, 0xac, 0x09, 0xc0, 0x74, 0x5a
        db  0x3c, 0x2b, 0x75, 0x03, 0xfe, 0x07, 0xc3, 0x3c
        db  0x2d, 0x75, 0x03, 0xfe, 0x0f, 0xc3, 0x3c, 0x3e
        db  0x75, 0x02, 0x47, 0xc3, 0x3c, 0x3c, 0x75, 0x02
        db  0x4f, 0xc3, 0x3c, 0x2e, 0x75, 0x08, 0x8a, 0x07
        db  0x50, 0xff, 0x55, 0x30, 0x58, 0xc3, 0x3c, 0x2c
        db  0x75, 0x06, 0xff, 0x55, 0x2c, 0x88, 0x07, 0xc3
        db  0x3c, 0x5b, 0x75, 0xfb, 0x89, 0xf3, 0x0f, 0xb6
        db  0x0f, 0xac, 0x3c, 0x5d, 0x75, 0x09, 0x80, 0x3f
        db  0x00, 0x74, 0xec, 0x89, 0xde, 0xeb, 0xf2, 0x3c
        db  0x5b, 0x74, 0x03, 0x67, 0xe3, 0xeb, 0x53, 0x51
        db  0x4e, 0xe8, 0xa3, 0xff, 0xff, 0xff, 0x59, 0x5b
        db  0xeb, 0xdf, 0x89, 0xec, 0x61, 0xc3

        на этом кратком, но тем не менее исчерпывающем введении можно
        остановиться и перейти собственно к вирусу, который в соответствии
        с загадочной эйверской логикой, был обозван Linux.Grip.a. впрочем,
        название мне нравится, а значит так тому и быть. Ж-)

        вирус представляет собой стандартный ELF-инфектор. тело расположено
        в конце файла. PT_NOTE заменяется на PT_LOAD. p_offset = filesize,
        p_align = 1, p_vadr = p_padr = ALIGN(min(PHDR.p_vaddr) - VSIZE, 4096),
        p_filesize = p_memsize = sizeof(virus) - тут, кстати, была ошибка,
        я забыл добавить к размеру вируса размер bf-программы, так что
        то что я сюда запостил будет работать только с файлами < PAGE_SIZE,
        я не заметил из-за того, что отлаживался на маленькой жертве, а
        вообще-то это багофича загрузчика (fs/binfmt_elf.c). одна из многих.
        странно, что до сих пор ни в Линуксе, ни во FreeBSD, так и не имеется
        нормального ELF-лоадера. точку входа не меняем, находим при помощи
        LDE32 (от Зомби) первый call, фиксим его, чтобы он указывал на тушку.
        заражаем по одному файлу за раз в текущем каталоге.

        с заражением все. он сказал: "Поехали!" и махнул рукой. переходим к
        шифрованию. от ставшего уже традицией XOR'а двордов (привет, Арви!),
        и от двойного XOR'а (дух захватывает!) решено было отказаться в
        пользу простого и эффективного XTEA (асемблерная реализация by
        Farshid Mossaiby). каковой XTEA является симметричным блочным шифром.
        рандомер для генерации ключа, был опять-таки утащен из TZ#1 и проверен
        при помощи ent. seed = time(NULL) ^ getpid() ^ RDTSC.HI ^ RDTSC.LO.

        ага. остался один неотвеченый вопрос. при чем здесь BrainFuck?

        собственно ему-то мы и обязаны текущим сабжем. дело в том, что
        взять вот так просто, и положить ключ расшифровки после тушки -
        это, согласитесь, полный некошер. поэтому добавим модуль, который
        преобразует ключ в программу на BF. вот так:

int _sqrt(int x)
{
        register int r;
        x = (x+1) >> 1;
        for (r = 0; x > r; x -= r++)
                ;
        return r;
}

#define S(c)    *code++ = c;
#define M(c,n)  for (i = 0; i < n; i++) S(c)
char *mk(char *code, int n)
{
        int     x, y, t, i;
        char    cmd;

        x = y = _sqrt(n);
        while ((t = (x * y)) < n)
                y++;
        t -= n;
        assert((x * y - t) == n);

        S('>');
        M('+', x)
        S('[');
        S('<');
        M('+', y)
        S('>');
        S('-');
        S(']');
        S('<');
        if (t < 0) {
                t = -t;
                cmd = '+';
        } else {
                cmd = '-';
        }
        M(cmd, t);
        S('>');

        return code;
}

        то, что нагенерит mk, записывается в конец файла (после зашифрованой
        тушки вируса). интерпретатор, xtea_decipher и цикл расшифровки
        располагаются в незашифрованой части вируса. вот теперь, пожалуй, все.
        сорцы интерпретатора лежат у меня на домашней страничке, сорцы первой
        версии сейчас положу. да. есть и вторая. "издание второе переработаное
        и дополненное", от него я положу бинари, так как бинарей там много,
        чуть ли не конструктор получился, в эху кидать не буду. да, и не гоже
        дрочить сверх меры местных ханжей.

p.s.    то чего очень не хватало в тексте письма:

                     .....
                 ..$MMMMMMM$..
               .$MMM$"$M$"$MMM$.
              $MMMM$" "M" "$MMMM$
            .$MMMMM!   $   !MMMMM$.
           .$MMMMMM:   ╨   :MMMMMM$.
           $MMMMMMM:   $   :MMMMMMM$
           M$M" "MM!   M   !MM" "M$M
           $$ ."MMM$. .M. .$MMM". $$
           "$MM "MMM$.$M$.$MMM" MM$"
            "$MM  "MMMMMMMMM"  MM$"
              $MM$  "$$M$$"  $MM$
               "$M$.       .$M$"
                 ""$$m...m$$""
                     """""

